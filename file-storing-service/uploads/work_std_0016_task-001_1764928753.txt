ОТЧЕТ: Асинхронная передача целых чисел через сигналы (SIGUSR1/SIGUSR2) (на 8 баллов)

ЗАДАНИЕ:
Реализовать две программы (передатчик и приёмник) для побитовой передачи целого
числа между процессами с использованием пользовательских сигналов SIGUSR1 и SIGUSR2.
Каждый бит кодируется отдельным сигналом: SIGUSR1 = 0, SIGUSR2 = 1.


РЕШЕНИЕ:

1. АРХИТЕКТУРА
   - sender.c: отправляет целое число (int) побитово от старшего бита к младшему
   - receiver.c: получает биты асинхронно через обработчики сигналов
   - Полностью асинхронная обработка событий в реальном времени

2. КЛЮЧЕВЫЕ КОМПОНЕНТЫ
   SENDER:
   - Принимает PID приёмника и целое число (включая отрицательные и ноль)
   - Преобразует число в двоичное представление (32 бита, two's complement)
   - Выводит бинарную строку
   - Отправляет первый бит (SIGUSR1 для 0, SIGUSR2 для 1)
   - Асинхронно ждёт подтверждения (SIGUSR1) от receiver'а
   - После получения подтверждения отправляет следующий бит
   - Использует volatile флаг ack_received для отслеживания подтверждений
   - Проверяет флаг в цикле с usleep(10)

   RECEIVER:
   - Регистрирует асинхронные обработчики для SIGUSR1 и SIGUSR2
   - sigusr1_handler: обрабатывает бит 0, отправляет подтверждение kill(sender_pid, SIGUSR1)
   - sigusr2_handler: обрабатывает бит 1, отправляет подтверждение kill(sender_pid, SIGUSR1)
   - Хранит PID sender'а в глобальной переменной для отправки подтверждений
   - Использует pause() для асинхронного ожидания сигналов
   - После получения 32 битов восстанавливает исходное число
   - Выводит двоичное представление и десятичный результат

3. ТЕХНИЧЕСКИЕ ОСОБЕННОСТИ

   Двоичное представление отрицательных чисел:
   - Используется дополнительный код
   - Преобразование через указатели: *(unsigned int *)&number
   - Восстановление: *(int *)&received_number
   - Работает для любого int: -2147483648, -2047, 0, 42, 2147483647

   Асинхронность:
   - Sender НЕ блокируется (использует цикл с проверкой флага)
   - Каждый бит отправляется после подтверждения предыдущего (примечание!)
   - Receiver асинхронно получает сигналы через pause() и обработчики
   - Гарантия доставки: ни один бит не потеряется
   - Соответствует требованию примечания о подтверждении


КОМПИЛЯЦИЯ:
gcc -o sender sender.c
gcc -o receiver receiver.c


ЗАПУСК:
Терминал 1:
  ./receiver

Терминал 2:
  ./sender

Далее выводится в консоли все ровно так же, как было показано на видео про асинхронное выполнение.